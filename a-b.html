<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
</head>

<body>
  <canvas id="canvas"></canvas>
</body>

<script id="shaderFs" type="x-shader/x-fragment">
precision highp float;
uniform float iTime;
uniform vec2 iMouse;
uniform vec2 iResolution;
//uniform vec2 iCamera;
// https://www.shadertoy.com/playlist/M3dSRf

// .x = f(p)
// .y = ∂f(p)/∂x
// .z = ∂f(p)/∂y
// .yz = ∇f(p) with ‖∇f(p)‖ = 1
vec3 sdgCircle( in vec2 p, in float r )  {
  float l = length(p);
  return vec3(l-r,p/l);
}
vec3 sdgBox( in vec2 p, in vec2 b ) {
  vec2 w = abs(p)-b;
  vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);
  float g = max(w.x,w.y);
  vec2  q = max(w,0.0);
  float l = length(q);
  return vec3((g>0.0)?l:g,
    s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));
}
vec3 sdgHex( in vec2 p, in float r )  {
  const vec3 k = vec3(-0.866025404,0.5,0.577350269);
  vec2 s = sign(p);
  p = abs(p);
	float w = dot(k.xy,p);    
  p -= 2.0*min(w,0.0)*k.xy;
  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);
  float d = length(p)*sign(p.y);
  vec2  g = (w<0.0) ? mat2(-k.y,-k.x,-k.x,k.y)*p : p;
  return vec3( d, s*g/d );
}

float u(float a,float b) {
  return min(a,b);
}
vec3 u(vec3 a,vec3 b) {
  return min(a,b);
}
float n(float a,float b) {
  return max(a,b);
}
vec3 n(vec3 a,vec3 b) {
  return max(a,b);
}
vec3 _(vec3 a,vec3 b) {
  return max(-b,a);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
	vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;
	vec2 uv = fragCoord/iResolution;
  //vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;

  float ra = 0.5;

  vec2 d = vec2(sin(iTime),cos(iTime))*sin(iTime)/2.;

  vec3 m = vec3(0);
	vec3 a = sdgCircle(p+d,ra);
	vec3 b = sdgCircle(p-d,ra);
	vec3 aub = u(a,b);
  vec3 anb = n(a,b);
  vec3 outp = n(_(a,b),aub);
  outp = u(outp,sdgBox(p+vec2(.875,.875),vec2(.0625)));
  aub = u(aub,sdgBox(p+vec2(.875,.75),vec2(.0625)));
  vec2 g = aub.yz;
  //g = vec2(dFdx(aub.x),dFdy(aub.x))/(2.0/iResolution.y);
    
	// coloring
  vec3 col = (aub.x>0.0) ? vec3(0.999,0.666,0.333) : vec3(0.333,0.666,.999);
  //vec3 col = (aub.x>0.0) ? vec3(uv,0) : vec3(uv,1);
  col *= 1.0 + vec3(.75*g,0.0);
  col *= (outp.x>0.0) ? vec3(1) : vec3(1)*(cos((p.x+p.y)*64.)*.5+.95);
  //col *= vec3(0.5+0.5*g,1.0);
  //col *= 1.0 - 0.5*exp(-32.0*abs(outp.x));
	//col *= .875 + 0.125*sin(128.*outp.x);
	col = mix(col,vec3(1),1.0-smoothstep(0.0,0.0125,abs(outp.x)));

	fragColor = vec4(col,1.0);
}
vec4 outCol;
void main() {mainImage(outCol, gl_FragCoord.xy);
  gl_FragColor=(outCol);
}
</script>
<script>
"use strict";

// Get A WebGL context
const canvas = document.querySelector("#canvas");
const gl = canvas.getContext("webgl2");

const resolution = 1024/4;
gl.canvas.width = resolution;
gl.canvas.height = resolution;
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

const vs_src = `attribute vec4 a_position;void main() {gl_Position = a_position;}`;

let mouseX = 0;
let mouseY = 0;

function setMousePosition(e) {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = rect.height - (e.clientY - rect.top) - 1;
  }

canvas.addEventListener('mousemove', setMousePosition);
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
}, {passive: false});
canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  setMousePosition(e.touches[0]);
}, {passive: false});

function main() {

  let fragment = document.getElementById("shaderFs").innerHTML;
  let fs_src = fragment;

  // setup GLSL program
  var vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, vs_src);
  gl.compileShader(vs);

  var fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, fs_src);
  gl.compileShader(fs);

  var program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);

  gl.detachShader(program, vs);
  gl.detachShader(program, fs);

  gl.useProgram(program);

  // look up uniform locations
  const resolutionLocation = gl.getUniformLocation(program,"iResolution");
  const mouseLocation = gl.getUniformLocation(program,"iMouse");
  const timeLocation = gl.getUniformLocation(program,"iTime");
  const camLocation = gl.getUniformLocation(program,"iCamera");
  const positionAttributeLocation = gl.getAttribLocation(program, "a_position");

  const vao = gl.createVertexArray();

  gl.bindVertexArray(vao);

  const positionBuffer = gl.createBuffer();

  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,  // first triangle
     1, -1,
    -1,  1,
    -1,  1,  // second triangle
     1, -1,
     1,  1,
  ]),gl.STATIC_DRAW);

  gl.enableVertexAttribArray(positionAttributeLocation);

  gl.vertexAttribPointer(
    positionAttributeLocation,
    2,
    gl.FLOAT,
    false,
    0,
    0,
  );

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    let log=`fs:${gl.getShaderInfoLog(fs)}\nvs:${gl.getShaderInfoLog(vs)}\npg:${gl.getProgramInfoLog(program)}\n`;
    console.log(log);
    gl.useProgram(null);
    gl.deleteProgram(program);
  }

  //gl.deleteShader(vs);
  //gl.deleteShader(fs);

  function render(time) {
    time*=.001;
    /*YawV = YawV*.9;
    Yaw = Yaw+YawV;
    PitchV = PitchV*.9;
    Pitch = Pitch+PitchV;*/
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
    gl.uniform2f(mouseLocation, mouseX, mouseY);
    gl.uniform1f(timeLocation, time);
    //gl.uniform2f(camLocation,Pitch,Yaw);
    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(render);
  }
  render();
}
main();
</script>

</html>
